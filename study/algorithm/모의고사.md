## 모의고사(완전탐색)

### Reference  
 - 프로그래머스 : https://programmers.co.kr/learn/courses/30/lessons/42840
 
### 문제
 - 완전탐색 : '모든 경우의 수를 전부 찾아서 답을 찾는 알고리즘' 을 뜻한다. 영어로는 Exhaustive Search 라고 한다. 가능한 모든 경우의 수를 다 해보는 것이다. 알고리즘을 풀때 가장 강력하고 확실한 방법이지만 그만큼 시간이 가장 오래 걸리는 탐색 기법이다
 
<img src = "https://user-images.githubusercontent.com/40849381/94021752-54cdb580-fdef-11ea-99c1-e4cf9a16d733.PNG"/>
 <br><br>

- java
 ```java
public class 모의고사 {
    public static int[] solution(int[] answers) {
        int[] person_1 = {1, 2, 3, 4, 5}, person_2 = {2, 1, 2, 3, 2, 4, 2, 5}, person_3 = {3, 3, 1, 1, 2, 2, 4, 4, 5, 5};
        int correctAnswer_1 = 0, correctAnswer_2 = 0, correctAnswer_3 = 0;
        for (int i = 0; i < answers.length; i++) {
            if (person1[i % person_1.length] == answers[i]) correctAnswer_1++;
            if (person2[i % person_2.length] == answers[i]) correctAnswer_2++;
            if (person3[i % person_3.length] == answers[i]) correctAnswer_3++;
        }
        int bestScore = Math.max(Math.max(answer1, answer2), answer3);
        List<Integer> list = new ArrayList<>();
        if (bestScore == correctAnswer_1) list.add(1);
        if (bestScore == correctAnswer_2) list.add(2);
        if (bestScore == correctAnswer_3) list.add(3);
        list.sort(Comparator.naturalOrder());
        int[] answer = new int[list.size()];
        for (int i = 0; i < list.size(); i++) {
            answer[i] = list.get(i);
        }
        return answer;
    }

```
- person_ 배열에 수포자의 패턴을 담음
- 정답을 맞추면 correctAnswer_ 값을 ++
- 정답을 가장 많이 맞춘 사람을 구함 
- 구해서 return
